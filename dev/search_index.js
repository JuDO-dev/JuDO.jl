var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = JuDO","category":"page"},{"location":"#JuDO","page":"Home","title":"JuDO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JuDO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [JuDO]","category":"page"},{"location":"#JuDO.Abstract_Dynamic_Model","page":"Home","title":"JuDO.Abstract_Dynamic_Model","text":"Dy_Model <: Abstract_Dynamic_Model\n\nAn abstract supertype Abstract_Dynamic_Model, for its subtype Dy_Model displaying the information of the model\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.Algebraic_Var_data","page":"Home","title":"JuDO.Algebraic_Var_data","text":"Algebraic_Var_data\n\nA DataType for storing a collection of algebraic variables\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.Constant_data","page":"Home","title":"JuDO.Constant_data","text":"Constant_data\n\nA DataType for storing a collection of constants\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.Constraint_data","page":"Home","title":"JuDO.Constraint_data","text":"constraint_data\n\nA DataType for storing a collection of constraints\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.Differential_Var_data","page":"Home","title":"JuDO.Differential_Var_data","text":"Differential_Var_data\n\nA DataType for storing a collection of differential variables\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.Independent_Var_data","page":"Home","title":"JuDO.Independent_Var_data","text":"Independent_Var_data\n\nA DataType for storing a collection of independent variables (currently for free/fixed time case)\n    # free/fixed start/end problem\n\n\n\n\n\n","category":"type"},{"location":"#JuDO.@constraint-Tuple{Any, Vararg{Any}}","page":"Home","title":"JuDO.@constraint","text":"@constraint(model, name, args...)\n\nThis macro is used to add one constraint (scalar or vector) into the model.\n\nThe user is required to put a dynamic model \"model\" as the first argument.\n    \n\"args...\" contains a name (symbol) for the constraint in its first element, the second element is the constraint function, \nthe third element it can be \"trajectory\", \"initial\", \"final\" or \"all\". \n\nThe equation must use \"==\", \"<=\", or \">=\" and each terms in the equation must contain either \na registered variable or constant, or a number.\n\nIn the constraint function, the user is required to add (\"name of the independent variable\") like ẋ(t), u(t), A(t)\nto indicate the dependency with respected to the independent variable.\n\nWhen performing multiplication or division, the user is required to use \"*\" or \"/\" to separate the terms when two adjacent\nbrackets or two adjacent symbols are present. For example, A(t)*(a*x(t)-1) is valid, but A(t)(a*x(t)-1) is not valid,\nA(t)x(t) is valid, but Ax(t) is not valid.\n\nStill, the user is encouraged to use \"*\" or \"/\" to describe the function whenever possible for minimizing the chance of error.\n\nDepending on the input function and set detected, the macro will call the corresponding DOI function to add the constraint,\nthe detail is shown in DynOptInterface Readme.\n\n        Function (subtypes):              Sets:                             Example:\n        LinearDifferentialFunction        NonpositiveForAll:                @constraint( model, c1, a*x(t) <= 0, trajectory)\n\n        LinearDifferentialFunction        NonnegativeForAll:                @constraint( model, c2, ẋ(t) - y(t) + p >= 0, trajectory)\n\n        LinearDifferentialFunction        ZeroForAll:                       @constraint( model, c3, ẋ(t) - sin(t) == 0, trajectory)\n        \n        VectorLinearDifferentialFunction, NonpositiveForAll:                @constraint( model, c4, B(t)*ẋ(t) - A(t)*x(t) <= 0, trajectory)\n\n        LinearAlgebraicFunction,          NonnegativeForAll:                @constraint( model, c5, u(t) - d/2 >= 0, trajectory)\n\n        LinearDifferentialAlgebraicFunction, ZeroForAll:                    @constraint( model, c6, u(t) - x(t)*d == 0, trajectory)\n\n        LinearDifferentialAlgebraicFunction, EqualToInitial:                @constraint( model, c7, u(t0) - x(t0)*d - 1 == 0, initial)\n        ...\n\n\n\n\n\n","category":"macro"}]
}
